{"version":3,"sources":["webpack://mfModules.[name]/./src/mobile.special.watchlist.scripts/WatchList.js","webpack://mfModules.[name]/./src/mobile.special.watchlist.scripts/WatchListGateway.js","webpack://mfModules.[name]/./src/mobile.special.watchlist.scripts/mobile.special.watchlist.scripts.js"],"names":["mfExtend","__webpack_require__","PageList","WatchstarPageList","ScrollEndEventEmitter","util","WatchListGateway","WatchList","params","lastTitle","options","extend","isBorderBox","this","scrollEndEventEmitter","eventBus","on","EVENT_SCROLL_END","_loadPages","bind","el","getLastTitle","gateway","api","call","preRender","disable","setElement","$el","postRender","$items","statuses","prototype","apply","queryUnitializedItems","Object","keys","parsePagesFromItems","reduce","title","renderItems","enable","loadWatchlist","then","pages","forEach","page","appendPage","render","templateOptions","wikidataDescription","undefined","append","templatePartials","item","find","attr","module","exports","Page","extendSearchParams","limit","continueParams","continue","gwrcontinue","replace","shouldSkipFirstTitle","canContinue","self","prop","rvprop","generator","gwrnamespace","gwrlimit","Deferred","resolve","get","url","apiUrl","data","parseData","query","sort","p1","p2","slice","map","newFromJSON","userOptions","mw","user","$","Api","view","filter","$watchlist","length","funnel","skipTemplateRender","remove","init","saveOption"],"mappings":"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","file":"mobile.special.watchlist.scripts.js","sourcesContent":["var\n\tmfExtend = require( '../mobile.startup/mfExtend' ),\n\tPageList = require( '../mobile.startup/PageList' ),\n\tWatchstarPageList = require( '../mobile.startup/watchstar/WatchstarPageList' ),\n\tScrollEndEventEmitter = require( '../mobile.startup/ScrollEndEventEmitter' ),\n\tutil = require( '../mobile.startup/util' ),\n\tWatchListGateway = require( './WatchListGateway' );\n\n/**\n * An extension of the WatchstarPageList which preloads pages as all being\n * watched.\n * @extends WatchstarPageList\n * @class WatchList\n * @uses ScrollEndEventEmitter\n *\n * @fires watched\n * @fires watch\n * @param {Object} params Configuration options\n * @param {OO.EventEmitter} params.eventBus Object used to listen for scroll:throttled events\n */\nfunction WatchList( params ) {\n\tvar lastTitle,\n\t\toptions = util.extend( {}, {\n\t\t\tisBorderBox: false\n\t\t}, params );\n\n\t// Set up infinite scroll helper and listen to events\n\tthis.scrollEndEventEmitter = new ScrollEndEventEmitter( options.eventBus );\n\tthis.scrollEndEventEmitter.on( ScrollEndEventEmitter.EVENT_SCROLL_END,\n\t\tthis._loadPages.bind( this ) );\n\n\tif ( options.el ) {\n\t\tlastTitle = this.getLastTitle( options.el );\n\t}\n\tthis.gateway = new WatchListGateway( options.api, lastTitle );\n\n\tWatchstarPageList.call( this, options );\n}\n\nmfExtend( WatchList, WatchstarPageList, {\n\t/**\n\t * @inheritdoc\n\t * @memberof WatchList\n\t * @instance\n\t */\n\tpreRender: function () {\n\t\t// The DOM will be modified. Prevent any false scroll end events from\n\t\t// being emitted.\n\t\tthis.scrollEndEventEmitter.disable();\n\t\tthis.scrollEndEventEmitter.setElement( this.$el );\n\t},\n\t/**\n\t * Also sets a watch uploads funnel.\n\t * @inheritdoc\n\t * @memberof WatchList\n\t * @instance\n\t */\n\tpostRender: function () {\n\t\tvar\n\t\t\t$items,\n\t\t\tstatuses;\n\n\t\t// Skip a level from WatchstarPageList directly to PageList.\n\t\tPageList.prototype.postRender.apply( this );\n\n\t\t$items = this.queryUnitializedItems();\n\n\t\t// WatchList requests list of watched pages. The list contains only\n\t\t// watched pages so it's safe to transform the title map to a status map\n\t\t// with each entry marked watched (true).\n\t\tstatuses = Object.keys( this.parsePagesFromItems( $items ) )\n\t\t\t.reduce( function ( statuses, title ) {\n\t\t\t\tstatuses[ title ] = true;\n\t\t\t\treturn statuses;\n\t\t\t}, {} );\n\t\tthis.renderItems( $items, statuses );\n\n\t\t// The list has been extended. Re-enable scroll end events.\n\t\tthis.scrollEndEventEmitter.enable();\n\t},\n\n\t/**\n\t * Loads pages from the api and triggers render.\n\t * Infinite scroll is re-enabled in postRender.\n\t * @memberof WatchList\n\t * @instance\n\t */\n\t_loadPages: function () {\n\t\tthis.gateway.loadWatchlist().then( function ( pages ) {\n\t\t\tpages.forEach( function ( page ) {\n\t\t\t\tthis.appendPage( page );\n\t\t\t}.bind( this ) );\n\t\t\tthis.render();\n\t\t}.bind( this ) );\n\t},\n\n\t/**\n\t * Appends a list item\n\t * @memberof WatchList\n\t * @instance\n\t * @param {Page} page\n\t */\n\tappendPage: function ( page ) {\n\t\t// wikidata descriptions should not show in this view.\n\t\tvar templateOptions = util.extend( {}, page.options, {\n\t\t\twikidataDescription: undefined\n\t\t} );\n\t\tthis.$el.append( this.templatePartials.item.render( templateOptions ) );\n\t},\n\n\t/**\n\t * Get the last title from the rendered HTML.\n\t * Used for initializing the API\n\t * @memberof WatchList\n\t * @instance\n\t * @param {jQuery.Object} $el Dom element of the list\n\t * @return {string}\n\t */\n\tgetLastTitle: function ( $el ) {\n\t\treturn $el.find( 'li:last' ).attr( 'title' );\n\t}\n} );\n\nmodule.exports = WatchList;\n","var Page = require( '../mobile.startup/Page' ),\n\tutil = require( '../mobile.startup/util' ),\n\textendSearchParams = require( '../mobile.startup/extendSearchParams' );\n\n/**\n * @class WatchListGateway\n * @param {mw.Api} api\n * @param {string} lastTitle of page listed in Watchlist to be used as a continuation parameter\n */\nfunction WatchListGateway( api, lastTitle ) {\n\tthis.api = api;\n\t// Try to keep it in sync with SpecialMobileWatchlist::LIMIT (php)\n\tthis.limit = 50;\n\n\tif ( lastTitle ) {\n\t\tthis.continueParams = {\n\t\t\tcontinue: 'gwrcontinue||',\n\t\t\tgwrcontinue: '0|' + lastTitle.replace( / /g, '_' )\n\t\t};\n\t\tthis.shouldSkipFirstTitle = true;\n\t} else {\n\t\tthis.continueParams = {\n\t\t\tcontinue: ''\n\t\t};\n\t\tthis.shouldSkipFirstTitle = false;\n\t}\n\n\tthis.canContinue = true;\n}\n\nWatchListGateway.prototype = {\n\t/**\n\t * Load the list of items on the watchlist\n\t * @return {jQuery.Deferred}\n\t */\n\tloadWatchlist: function () {\n\t\tvar self = this,\n\t\t\tparams = extendSearchParams( 'watchlist', {\n\t\t\t\tprop: [ 'info', 'revisions' ],\n\t\t\t\trvprop: 'timestamp|user',\n\t\t\t\tgenerator: 'watchlistraw',\n\t\t\t\tgwrnamespace: '0',\n\t\t\t\tgwrlimit: this.limit\n\t\t\t}, this.continueParams );\n\n\t\tif ( this.canContinue === false ) {\n\t\t\treturn util.Deferred().resolve( [] );\n\t\t}\n\t\treturn this.api.get( params, {\n\t\t\turl: this.apiUrl\n\t\t} ).then( function ( data ) {\n\t\t\tif ( data.continue !== undefined ) {\n\t\t\t\tself.continueParams = data.continue;\n\t\t\t} else {\n\t\t\t\tself.canContinue = false;\n\t\t\t}\n\n\t\t\treturn self.parseData( data );\n\t\t} );\n\t},\n\n\t/**\n\t * Parse api response data into pagelist item format\n\t * @param {Object[]} data\n\t * @return {Page[]}\n\t */\n\tparseData: function ( data ) {\n\t\tvar pages;\n\n\t\tif ( !data.query || !data.query.pages ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tpages = data.query.pages;\n\n\t\t// Sort results alphabetically (the api map doesn't have any order). The\n\t\t// watchlist is ordered alphabetically right now.\n\t\tpages.sort( function ( p1, p2 ) {\n\t\t\treturn p1.title === p2.title ? 0 : ( p1.title < p2.title ? -1 : 1 );\n\t\t} );\n\n\t\t// If we requested from the last item of the previous page, we shall\n\t\t// remove the first result (to avoid it being repeated)\n\t\tif ( this.shouldSkipFirstTitle ) {\n\t\t\tpages = pages.slice( 1 );\n\t\t\tthis.shouldSkipFirstTitle = false;\n\t\t}\n\n\t\t// Transform the items to a sensible format\n\t\treturn pages.map( Page.newFromJSON );\n\t}\n\n};\n\nmodule.exports = WatchListGateway;\n","/* global $ */\nvar WatchList = require( './WatchList' ),\n\teventBus = require( '../mobile.startup/eventBusSingleton' ),\n\tVIEW_OPTION_NAME = 'mfWatchlistView',\n\tuserOptions = mw.user.options.get(),\n\tFILTER_OPTION_NAME = 'mfWatchlistFilter';\n\n/**\n * Initialises JavaScript on Special:Watchlist\n */\nfunction init() {\n\tvar $watchlist = $( 'ul.page-list' );\n\n\t// FIXME: find more elegant way to not show watchlist stars on recent changes\n\tif ( $( '.mw-mf-watchlist-selector' ).length === 0 ) {\n\t\t// eslint-disable-next-line no-new\n\t\tnew WatchList( {\n\t\t\tapi: new mw.Api(),\n\t\t\tel: $watchlist,\n\t\t\tfunnel: 'watchlist',\n\t\t\tskipTemplateRender: true,\n\t\t\teventBus: eventBus\n\t\t} );\n\t}\n\t// not needed now we have JS view which has infinite scrolling\n\t$( '.more' ).remove();\n}\n\n$( function () {\n\tvar api = new mw.Api(),\n\t\tview = $( '.button-bar .is-on a' ).data( 'view' ),\n\t\tfilter = $( '.mw-mf-watchlist-selector .selected a' ).data( 'filter' );\n\n\tinit();\n\t// Only save if the value has changed.\n\tif ( view !== userOptions[VIEW_OPTION_NAME] ) {\n\t\tapi.saveOption( VIEW_OPTION_NAME, view );\n\t}\n\tif ( filter && filter !== userOptions[FILTER_OPTION_NAME] ) {\n\t\tapi.saveOption( FILTER_OPTION_NAME, filter );\n\t}\n} );\n"],"sourceRoot":""}